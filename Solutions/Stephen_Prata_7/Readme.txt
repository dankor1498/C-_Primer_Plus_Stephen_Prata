1. Напишите программу, которая многократно запрашивает у пользователя пару
чисел до тех пор, пока хотя бы одно из этой пары не будет равно 0. С каждой 
парой программа должна использовать функцию для вычисления среднего
гармонического этих чисел. Функция должна возвращать ответ main() для 
отображения результата. Среднее гармоническое чисел — это инверсия среднего
значения их инверсий; она вычисляется следующим образом:
среднее гармоническое = 2.0 * х * у / (х+у)

2. Напишите программу, которая запрашивает у пользователя 10 результатов игры
в гольф, сохраняя их в массиве. При этом необходимо обеспечить возможность
прекращения ввода до ввода всех 10 результатов. Программа должна отобразить
все результаты в одной строке и сообщить их среднее значение. Реализуйте
ввод, отображение и вычисление среднего в трех отдельных функциях, работающих с массивами.

3. Пусть имеется следующее объявление структуры:
struct box
{
	char maker[40];
	float height;
	float width;
	float length;
	float volume;
};
а. Напишите функцию, принимающую структуру box по значению и отображающую все ее члены.
б. Напишите функцию, принимающую адрес структуры box и устанавливающую
значение члена volume равным произведению остальных трех членов.
в. Напишите простую программу, которая использует эти две функции.

4. Многие лотереи в США организованы подобно той, что была смоделирована
в листинге 7.4. Во всех их вариациях вы должны выбрать несколько чисел из
одного набора, называемого полем номеров. (Например, вы можете выбрать 5
чисел из поля 1-47.) Вы также указываете один номер (называемый меганомером) 
из второго диапазона, такого как 1-27. Чтобы выиграть главный приз, вы
должны правильно угадать все номера. Шанс выиграть вычисляется как вероятность 
угадывания всех номеров в поле, умноженная на вероятность угадывания меганомера. 
Например, вероятность выигрыша в описанном здесь примере вычисляется как 
вероятность угадывания 5 номеров из 47, умноженная на
вероятность угадывания одного номера из 27. Модифицируйте листинг 7.4 для
вычисления вероятности выигрыша в такой лотерее.

5. Определите рекурсивную функцию, принимающую целый аргумент и возвращающую его 
факториал. Вспомните, что факториал 3 записывается, как 3! и
вычисляется как 3x2! и т.д., причем 0! равно 1. В общем случае, если n больше
нуля, то n! = n * (n-1)!. Протестируйте функцию в программе, использующей
цикл, где пользователь может вводить различные значения, для которых программа 
вычисляет и отображает факториалы.

6. Напишите программу, использующую описанные ниже функции.
Fill_array() принимает в качестве аргумента имя массива элементов типа
double и размер этого массива. Она приглашает пользователя ввести значения 
double для помещения их в массив. Ввод прекращается при наполнении массива 
либо когда пользователь вводит нечисловое значение и возвращает действительное количество элементов.
Show_array() принимает в качестве аргументов имя массива значений double,
а также его размер, и отображает содержимое массива.
Reverse_array() принимает в качестве аргумента имя массива значений
double, а также его размер, и изменяет порядок его элементов на противоположный.
Программа должна использовать эти функции для наполнения массива, обращения порядка 
его элементов, кроме первого и последнего, с последующим
отображением.

7. Вернитесь к программе из листинга 7.7 и замените три функции обработки массивов 
версиями, которые работают с диапазонами значений, заданными парой
указателей. Функция fill_array() вместо возврата действительного количества 
прочитанных значений должна возвращать указатель на место, следующее за
последним введенным элементом; прочие функции должны использовать его в
качестве второго аргумента для идентификации конца диапазона данных.

8. Вернитесь к программе из листинга 7.15, не использующей класс array. 
Напишите следующие две версии.
а. Используйте обычный массив из const char* для строковых представлений
времен года и обычный массив из double для расходов.
б. Используйте обычный массив из const char* для строковых представлений 
времен года и структуру, единственный член которой является обычным
массивом из double для расходов. (Это очень похоже на базовое проектное
решение для класса array.)

9. Следующее упражнение позволит попрактиковаться в написании функций, 
работающих с массивами и структурами. Ниже представлен каркас программы.
Дополните его функциями, описанными в комментариях.

#include <iostream>

using namespace std;

const int SLEN = 30;
struct student {
	char fullname[SLEN];
	char hobby[SLEN];
int ooplevel;
};

// getinfo() принимает два аргумента: указатель на первый элемент
// массива структур student и значение int, представляющее
// количество элементов в массиве. Функция запрашивает и
// сохраняет данные о студентах. Ввод прекращается либо после
// наполнения массива, либо при вводе пустой строки в качестве
// имени студента. Функция возвращает действительное количество
// введенных элементов.
int getinfо (student ра[], int n) ;
// display1() принимает в качестве аргумента структуру student
// и отображает ее содержимое.
void displayl(student st) ;
// display2() принимает адрес структуры student в качестве аргумента
// и отображает ее содержимое,
void display2(const student * ps) ;
// display3() принимает указатель на первый элемента массива
// структур student и количество элементов в этом массиве и
// отображает содержимое всех структур в массиве,
void display3(const student pa[], int n);

int main ()
{
cout << "Enter class size: ";
int class_size;
cin >> class_size;
while (cin.getO != '\n')
	continue;
student *ptr_stu = new student[class_size];
int entered = getinfо (ptr_stu, class_size);
for (int i = 0; i < entered; i + + )
{
	display1(ptr_stu [i] ) ;
	display2(&ptr_stu[i]);
}
display3(ptr_stu, entered);
delete []ptr_stu;
cout << "Done\n";
return 0;
}

10. Спроектируйте функцию calculate(), которая принимает два значения типа
double и указатель на функцию, принимающую два аргумента double и возвращающую 
значение double. Функция calculate() также должна иметь тип
double и возвращать значение, вычисленное функцией, которая задана указателем, 
используя аргумент double функции calculate(). Например, предположим, что 
имеется следующее определение функции add():
double add(double x, double y)
{
	return x + y;
}
Приведенный ниже вызов функции должен заставить calculate() передать
значения 2.5 и 10.4 функции add() и вернуть ее результат (12.9):
double q = calculate(2.5, 10.4, add);
Используйте в программе эти функции и еще хотя бы одну дополнительную, которая подобна add(). 
В программе должен быть организован цикл, позволяющий пользователю вводить пары чисел. 
Для каждой пары calculate() должна вызвать add() и хотя бы еще одну функцию такого рода. 
Если вы чувствуете себя уверенно, попробуйте создать массив указателей на функции, подобные
add(), и организуйте цикл, применяя calculate() для вызова этих функций
по их указателям. Подсказка: вот как можно объявить массив из трех таких указателей:
double (*pf[3]) (double, double);
Инициализировать такой массив можно с помощью обычного синтаксиса инициализации массивов и 
имен функций в качестве адресов.